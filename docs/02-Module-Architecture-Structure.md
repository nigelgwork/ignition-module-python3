# Ignition SDK - Module Architecture and Structure

## Module Anatomy

### What is a Module?

A module is a `.modl` file that Ignition loads and integrates into the platform. The `.modl` file is simply a ZIP archive containing:

1. **JAR files**: Compiled Java code for each scope
2. **module.xml**: Module manifest/descriptor
3. **Optional files**: License file, documentation, resources

## Module Descriptor (module.xml)

The `module.xml` file describes your module to Ignition. It's automatically generated by the build tools but understanding its structure is important.

### Key Elements

```xml
<?xml version="1.0" encoding="UTF-8"?>
<modules>
    <module>
        <!-- Unique identifier (reverse domain notation) -->
        <id>com.company.mymodule</id>
        
        <!-- Human-readable name -->
        <name>My Custom Module</name>
        
        <!-- Module description -->
        <description>Custom functionality for Ignition</description>
        
        <!-- Version number (semantic versioning) -->
        <version>1.0.0</version>
        
        <!-- Minimum Ignition version required -->
        <requiredIgnitionVersion>8.3.0</requiredIgnitionVersion>
        
        <!-- Required framework version -->
        <requiredFrameworkVersion>8</requiredFrameworkVersion>
        
        <!-- License information (optional) -->
        <license>license.html</license>
        
        <!-- Documentation (optional) -->
        <documentation index="doc/index.html"/>
        
        <!-- Module dependencies -->
        <depends scope="G">com.inductiveautomation.vision</depends>
        
        <!-- JAR files and their scopes -->
        <jar scope="G">mymodule-gateway.jar</jar>
        <jar scope="D">mymodule-designer.jar</jar>
        <jar scope="C">mymodule-client.jar</jar>
        <jar scope="GD">mymodule-common.jar</jar>
        
        <!-- Hook classes -->
        <hooks>
            <hook scope="G">com.company.mymodule.gateway.GatewayHook</hook>
            <hook scope="D">com.company.mymodule.designer.DesignerHook</hook>
            <hook scope="C">com.company.mymodule.client.ClientHook</hook>
        </hooks>
    </module>
</modules>
```

### Scope Notation
- **G** = Gateway
- **D** = Designer  
- **C** = Client (Vision)
- **GD** = Gateway + Designer
- **GDC** = All three scopes

## Scopes in Detail

### Gateway Scope (G)

**Purpose**: Server-side logic running in the Ignition Gateway

**Use Cases**:
- OPC-UA device drivers
- Tag providers
- Database operations
- Scheduled tasks
- Alarm notification handlers
- Web services
- Gateway status pages
- System-wide resources

**Characteristics**:
- Runs continuously with Gateway
- One instance per Gateway
- Access to all platform services
- Must be thread-safe
- Long-running operations acceptable

**Context**: `GatewayContext`

### Designer Scope (D)

**Purpose**: Design-time tools and functionality

**Use Cases**:
- Component palette additions
- Property editors
- Custom wizards
- Project resource manipulation
- RPC communication with Gateway
- Design-time validation

**Characteristics**:
- Runs in Designer application
- One instance per Designer session
- Access to project resources
- UI interactions
- RPC calls to Gateway

**Context**: `DesignerContext`

### Client Scope (C)

**Purpose**: Vision client runtime (legacy)

**Use Cases**:
- Vision component runtime behavior
- Client-side scripting functions
- Custom client logic

**Characteristics**:
- Runs in Vision clients only
- Not used for Perspective
- One instance per client
- Limited platform access

**Context**: `VisionClientContext`

**Note**: Perspective doesn't use Client scope - it uses web technologies and communicates with Gateway via WebSocket.

## Hook Classes

### Module Hook Lifecycle

Every hook class goes through three lifecycle phases:

#### 1. setup() Phase
```java
@Override
public void setup(GatewayContext context) {
    this.context = context;
    // Register extension points
    // Initialize persistent records
    // Do NOT modify database here
}
```

**Purpose**: Early initialization before most platform services are available
- Register extension point types
- Initialize schemas and persistent records
- Store context reference
- Prepare for startup

**Restrictions**:
- Many platform functions unavailable
- Can query database, but don't modify
- Other modules may not be loaded yet
- Keep operations minimal

#### 2. startup() Phase
```java
@Override
public void startup(LicenseState licenseState) {
    // Start background threads
    // Initialize managers
    // Register with platform services
    // Perform database modifications
}
```

**Purpose**: Main initialization when all platform services are available
- Start background processes
- Register components, functions, etc.
- Subscribe to platform events
- Initialize module functionality

**Key Points**:
- All dependencies are loaded
- Platform services available
- Okay to modify database
- Check license state if needed

#### 3. shutdown() Phase
```java
@Override
public void shutdown() {
    // Stop background threads
    // Clean up resources
    // Unregister listeners
    // Close connections
}
```

**Purpose**: Clean shutdown when module is stopped or Ignition shuts down
- Stop all threads
- Release resources
- Unregister listeners
- Save state if needed

**Critical**: Failure to clean up properly can cause memory leaks or prevent Ignition shutdown

### Gateway Hook Template

```java
package com.company.mymodule.gateway;

import com.inductiveautomation.ignition.common.licensing.LicenseState;
import com.inductiveautomation.ignition.gateway.model.AbstractGatewayModuleHook;
import com.inductiveautomation.ignition.gateway.model.GatewayContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class GatewayHook extends AbstractGatewayModuleHook {
    
    private final Logger logger = LoggerFactory.getLogger(getClass());
    private GatewayContext context;
    
    @Override
    public void setup(GatewayContext context) {
        this.context = context;
        logger.info("Setting up module");
        
        // Register extension points
        // Initialize persistent records
    }
    
    @Override
    public void startup(LicenseState licenseState) {
        logger.info("Starting up module");
        
        // Initialize module functionality
        // Start background processes
        // Register with platform services
    }
    
    @Override
    public void shutdown() {
        logger.info("Shutting down module");
        
        // Stop threads
        // Clean up resources
        // Unregister listeners
    }
    
    // Optional: Provide RPC handler for Designer communication
    @Override
    public Object getRPCHandler(ClientReqSession session, String projectId) {
        return new ModuleRPCHandler(context);
    }
    
    // Optional: Module configuration
    @Override
    public boolean isMakerEditionCompatible() {
        return true; // Allow in Maker Edition
    }
    
    @Override
    public boolean isFreeModule() {
        return false; // Requires license
    }
}
```

### Designer Hook Template

```java
package com.company.mymodule.designer;

import com.inductiveautomation.ignition.common.licensing.LicenseState;
import com.inductiveautomation.ignition.designer.model.AbstractDesignerModuleHook;
import com.inductiveautomation.ignition.designer.model.DesignerContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DesignerHook extends AbstractDesignerModuleHook {
    
    private final Logger logger = LoggerFactory.getLogger(getClass());
    private DesignerContext context;
    
    @Override
    public void setup(DesignerContext context) {
        this.context = context;
        logger.info("Setting up designer module");
    }
    
    @Override
    public void startup(LicenseState licenseState) {
        logger.info("Starting up designer module");
        
        // Register components with palette
        // Add menu items
        // Register property editors
    }
    
    @Override
    public void shutdown() {
        logger.info("Shutting down designer module");
        
        // Clean up resources
    }
}
```

## Project Structure

### Typical Multi-Scope Module

```
my-module/
├── build.gradle.kts (or settings.gradle.kts)
├── gradle/ (Gradle wrapper files)
├── common/
│   ├── build.gradle.kts
│   └── src/main/java/
│       └── com/company/mymodule/
│           └── common/
│               ├── Constants.java
│               └── SharedModel.java
├── gateway/
│   ├── build.gradle.kts
│   └── src/main/java/
│       └── com/company/mymodule/
│           └── gateway/
│               ├── GatewayHook.java
│               └── ModuleRPCHandler.java
├── designer/
│   ├── build.gradle.kts
│   └── src/main/java/
│       └── com/company/mymodule/
│           └── designer/
│               ├── DesignerHook.java
│               └── ComponentPaletteEntry.java
└── client/ (if needed for Vision)
    ├── build.gradle.kts
    └── src/main/java/
        └── com/company/mymodule/
            └── client/
                ├── ClientHook.java
                └── ComponentRuntime.java
```

### Package Naming Convention

Use reverse domain notation:
```
com.company.modulename.scope
```

Examples:
- `com.inductiveautomation.vision.gateway`
- `org.ignitionmdc.barcodedecoder.designer`
- `net.mycompany.customdriver.common`

## Common Scope Usage

The Common scope is for code shared between multiple scopes:

```java
// common/src/main/java/com/company/mymodule/common/
public class SharedConstants {
    public static final String MODULE_ID = "com.company.mymodule";
    public static final String RPC_INTERFACE = "ModuleRPC";
}

public interface ModuleRPC {
    String getMessage(String input);
}

public class SharedDataModel {
    private String name;
    private int value;
    // getters/setters
}
```

JAR scope in module.xml: `GD` (Gateway + Designer) or `GDC` (all three)

## Extension Points

Modules integrate with Ignition through extension points:

### Common Extension Points

1. **Scripting Functions** (`ScriptManager`)
   - Add Python functions to system.* namespaces

2. **Expression Functions** (`ExpressionFunctionManager`)
   - Add custom expression functions

3. **Component Palette** (Vision/Perspective)
   - Add custom components

4. **Device Types** (`DeviceTypeManager`)
   - Add OPC-UA device drivers

5. **Tag Providers** (`TagManager`)
   - Implement custom tag providers

6. **Alarm Notification** (`AlarmNotificationProfileManager`)
   - Custom notification types

7. **Gateway Web Pages** (`WebServerManager`)
   - Add configuration pages

8. **Database Interactions** (`DatabaseManager`)
   - Custom database operations

9. **Report Components** (`ReportingContext`)
   - Custom report elements

10. **Project Resources** (`ProjectManager`)
    - Custom resource types

### Registering Extension Points

```java
@Override
public void startup(LicenseState licenseState) {
    // Register scripting function
    context.getScriptManager().addScriptModule(
        "system.example",
        new ScriptFunctionImpl(),
        new PropertiesFileDocProvider()
    );
    
    // Register expression function
    context.getExpressionFunctionManager()
        .addFunction("customFunc", CustomExpressionFunction.class);
}
```

## Module Dependencies

Declare dependencies on other modules in build configuration:

### Gradle
```kotlin
dependencies {
    // SDK dependencies (provided by platform)
    compileOnly("com.inductiveautomation.ignitionsdk:ignition-common:${sdkVersion}")
    compileOnly("com.inductiveautomation.ignitionsdk:gateway-api:${sdkVersion}")
    
    // Module dependencies
    modlApi("com.inductiveautomation.ignitionsdk:vision-common:${sdkVersion}")
    
    // Third-party libraries (will be included in module)
    modlImplementation("com.google.gson:gson:2.8.9")
}
```

### module.xml
```xml
<depends scope="G">com.inductiveautomation.vision</depends>
<depends scope="D">com.inductiveautomation.perspective</depends>
```

## Inter-Scope Communication

### Designer to Gateway (RPC)

Modules often need Designer to communicate with Gateway:

```java
// Gateway side - implement handler
public class ModuleRPCHandler implements ModuleRPC {
    @Override
    public String getMessage(String input) {
        return "Processed: " + input;
    }
}

// In GatewayHook
@Override
public Object getRPCHandler(ClientReqSession session, String projectId) {
    return new ModuleRPCHandler();
}

// Designer side - call Gateway
ModuleRPC rpc = ModuleRPCFactory.create(
    "com.company.mymodule",
    ModuleRPC.class
);
String result = rpc.getMessage("Hello");
```

### Gateway to Perspective (WebSocket)

Perspective components communicate via WebSocket automatically through the Perspective API.

## Persistent Configuration

Use `PersistentRecord` for module settings:

```java
public class ModuleSettings extends PersistentRecord {
    public static final RecordMeta<ModuleSettings> META = 
        new RecordMeta<>(ModuleSettings.class, "ModuleSettings");
    
    public static final IdentityField Id = 
        new IdentityField(META, "Id");
    
    public static final StringField Hostname = 
        new StringField(META, "Hostname");
    
    public static final IntField Port = 
        new IntField(META, "Port");
    
    @Override
    public RecordMeta<?> getMeta() {
        return META;
    }
}
```

Register in setup():
```java
context.getSchemaUpdater().updatePersistentRecords(ModuleSettings.META);
```

## Best Practices

### ✅ Do
- Extend Abstract hook classes
- Store context in field for later use
- Use proper logging (SLF4J)
- Implement clean shutdown
- Test each scope independently
- Document public APIs
- Handle exceptions gracefully
- Use thread-safe operations

### ❌ Don't
- Block in setup() method
- Forget to stop threads in shutdown()
- Modify database in setup()
- Ignore license state
- Use System.out.println (use logger)
- Create memory leaks
- Hardcode configuration values

## Troubleshooting

### Module Won't Load
- Check module.xml syntax
- Verify hook class paths
- Check dependency versions
- Review Gateway logs

### Module Loads but Doesn't Work
- Verify hook methods are called
- Check for exceptions in logs
- Confirm extension points registered
- Test RPC communication

### Module Causes Gateway Issues
- Check for unclosed resources
- Verify thread shutdown
- Look for memory leaks
- Profile with JVM tools

## Module Signing (Production)

For production modules, implement proper signing:

1. Generate keystore
2. Configure signing in build
3. Test signed module
4. Distribute public certificate

Development: Set `skipModlSigning=true` and allow unsigned modules in Ignition.
